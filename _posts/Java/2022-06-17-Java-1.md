---
title:  "JAVA 단어공부"
excerpt : "자바공부 끄적끄적."

categories:
  - Java
tags:
  - Java

toc: true
toc_sticky: true
 
date: 2022-06-17
last_modified_at: 2022-06-17
---

# 자바 단어복습
 - 오버라이딩
   - 오버라이트로 기억. 덮어쓰기. 부모의 함수를 재정의한다.
- 오버로딩
  - 파라미터 타입이나 갯수가 다를때 이름이 같으면서 새롭게 함수를 정의 
    - 이름을 생각하는 고민의 시간을 줄여준다.
    -  이름은 그 함수가 하는 일이 함축되어 있기 때문에 하는 일이 같음을 유추할수있다.
- 객체
  - 우리가 프로그램으로 구현할 대상
  - 자바에서는 Class 로 객체를 설계한다.
  - 생성자를 통해 인스턴스를 만든다.
  - 인스턴스가 되어야 비로소 메모리에 올라가고 실체화 된다.
  - 객체는 변수와 메소드의 묶음이다.
  - 속성과 행동의 묶음이다.
- 생성자
  - 인스턴스를 만들때 new키워드와 함께 쓰인다.
  - 함수와 비슷하게 생겼지만 이름이 클래스와 같고, 리턴 타입이 없다.
  - 인스턴스를 만들때 반드시 필요한 데이터를 강제하는 역할을 한다.
  - 준비되지 않은 상태라면 인스턴스를 만들수없도록 한다.
  - 생성자를 명시하지 않은경우 컴파일러가 자동으로 부모의 디폴트 생성자를 호출한다. super();
  - 그렇기 때문에 부모의 생성자를 호출하지 않는다면 컴파일 에러가 난다.
  - 생성자예시
--- 
    
      Apple myfruit = new Apple();

---      

# 상속
- 상속의 구조
  - 자식클래스 extends 부모클래스
- 부모의 변수와 메소드를 자식에서 코딩하지 않고도 그대로 사용할 수 있다.
- 부모 클래스는 하나밖에 못둔다.
- 동시에 2개이상의 클래스로부터는 상속이 불가하다.
- 내가 부모클래스를 만들어 상속을 받으려 한다면 is a 관계인지 확인해야한다.
- has a 관계로 상속관계를 구현하는 실수를 하기 쉽다.
  - ex) 사각형(자식)은 도형(부모)이다 (가능)
  - 도형은 사각형이다 (불가능)
- 부모에 선언된 변수와 같은 이름으로 자식에 선언한다면 자식의 것이 사용이된다.(오버라이딩개념이다.)
- 예를들어 name 라는 값을 썻으면 나에게 그변수가 존재하는지를 먼저찾고 이후에 부모에게서 찾는다.
- 이런식으로 부모에도 없다면 최종적으로 Object 에 도달하여 찾게된다.


# to string
-  to string 객체는 call by reference 이기 때문에 객체를 출력하면 객체의 값이아니라 주소가 출력된다.
-  객체를 출력했을때 자동으로 호출되는 함수가 toString 이고 사용자 정의를 하지 않았다면 기본적인 주소가 출력된다.
-  toString를 통하여 값을 출력하도록 만들수있다.
-  이클립스에서는 이것을 쉽게 만들수 있도록 제공하는데 source - generate toString 들어가서  원하는 변수들을 체크해주면 값들이 찍히게됨




# 이클립스 단축키
- 이클립스 단축키 복습
	- ctrl space : 자동완성
	- ctrl shift r : 파일명으로 바로찾기.
	- ctrl d : 한줄지우기
	- ctrl shift 키보드 아래 : 해당블록 복붙
	- f3 정의부로 이동
	- alt shift s : Source
	- ctrl shift o : 자동 import
	- ctrl shift f : 자동 들여쓰기.
	- ctrl shift p : 자동 짝 찾기.
- 외울필요는 없다.


# 배열 Array
- 배열은 동일한 자료형의 순차적인 자료구조이다.
- 같은 데이터타입의 연관된 여러개의 데이터를 하나의 변수에 담아서 쉽게 관리 할 수 있도록 해주는 자료구조중 하나이다.
- 인덱스(색인)은 0부터 시작한다.
- 장점 : 인덱스를 활용하여 빠른 참조가 가능하다.
- 단점 : 크기가 선언이됬을시 크기를 바꿀수 없다.
- 생성법 
  - 자료형[] 배열이름 = {값1, 값2, 값3...};
  - 자료형[] 배열이름 = new 자료형[크기];
- 배열의 모든요소출력
  - 반복문을 쓰거나 Arrays.toString(배열명)
- 자바의 단점 : 배열의 크기가 정해져있다.
- length : 배열에서의 length는 다른언어와 다르게 처음 지정해준 길이를 뜻한다.

# 얕은복사
- 한 쪽에서 수정이 발생되면 다른쪽에도 영향을 끼쳐 같아지게 된다.
- 가능한 이유는 얕은 복사가 주소값을 복사하기때문에 주소로 참조하여 값이 변경되면 값을 참조하고 있는 배열들의 값이 변경된다.
- 즉, 복사된 배열이나 원본 배열이 변경될때, 함께 변경된다. = 연산자는 얕은 복사를 수행한다.

---

    int[] a = new int[2];
    a[0] = 2;
    a[1] = 4;
    int[] b = a;
    b[0] = 6;
    b[1] = 8;

    System.out.println(a[0]+", "+a[1]);
    System.out.println(b[0]+", "+b[1]);

    // 결과
    6, 8
    6, 8
---

- 위의 코드 처럼 1차원 배열을 = 연산자를 사용해 얕은 복사를 진행하게 되면 복사된 배열의 값이 변경될때 원본 배열의 값도 변경된다.

# 깊은 복사
- 깊은복사는 주소값을 참조하는것이 아닌 새로운 메모리 공간에 값을 복사하는 것이기 때문에 원본 배열이 변경되어도 복사된배열에 전혀 상관이없다.
- 따라서 배열을 복사한 후 한쪽 값을 수정해도 다른 배열에 영향을 끼치지 않는다.

1. 1차원 배열의 깊은복사
   - 1차원 배열의 깊은복사는 배열.clone() 함수를 이용하면 간단하게 할수있다.(일반자료형의 경우)
   - 혹은 간다헤 for 문을 돌며 넣어주어도 된다.
  