---
title:  "JAVA 기초공부"
excerpt : "자바공부 끄적끄적."

categories:
  - Java
tags:
  - Java

toc: true
toc_sticky: true
 
date: 2022-06-16
last_modified_at: 2022-06-16
---

- 이클립스(STS) 는 JDK를 통해서 컴파일하지않는다. 기본적으로 내장된 컴파일러을 사용한다.
- 바꾸고 싶다면 Window -> Preferences -> Java -> Compile에서 변경 11버전으로
- 그런데 런타임 환경은 사용자가 설치한 것을 사용한다.
- 바꾸고 싶으면  Window->Preferences->installed jre

# while for 

- 언제 while 를 사용하고 언제 for을 사용하는가.??
	- 조건이 '상황,컨디션' 으로 정해지면 while 이 편하고
	- 조건이 '횟수'로 정해지면 for가 편하다.
	- 하지만 for와 while은 서로 변환할수 있다.
- 객체 
	- 프로그램으로 구현할 대상이 객체이다.
	- 대상을 상태와 행위로 구분해서 가져옴
	- 상태 : 변수 , 행위 : 함수
	- 예) 고양이라는 객체 .
		실제 고양이에서 우리 프로그램에서 구현할 고양이는 어떤 속성을 가지고있고, 어떤 행위를 할수 있을 것인가를 
		생각혀여 고양이를 만들어야함.
		속성 : 털색 키 몸무게 품종 나이
		행위 : 걷기 뛰기 구르기 할퀴기 자기 먹기 등등
	- '추상화' : 추상화는 해결해야할 문제 반영해야할 현실을 - 소프트웨어방식으로 단순화하는 행위를 말한다.
		예) 실제 위성사진 -> 네이버 지도 -> 실제 위치로 박힌 지하철 노선도 -> 우리가 보는 지하철 노선도
	- '부품화' : 우리가만든객체가 다른곳에서 사용할수있게끔 사용하게만듬.즉 다른곳에서 부품으로써 사용되는것
	- 로직을 재활용할수있게 만들어야함.
		- 예) 초창기의 컴퓨터.  현재의 컴퓨터 : 모니터, 본체, 키보드 등이 분리. 그안에서도 또 분리. 어디가 고장났는지 쉽게 알수있고 그것만 교체하면된다.
		시대에 따라, 환경에 따라 부품화 및 추상화의 관점은 계속 바뀐다. 무조건 부품화를 하는것이 좋은것이 아니다. 정답이 없다.
		메소드도 부품화의 예. 메소드가 도입되면서 과거와 비교해서 훨씬 편하게 프로그래밍 할 수 있게 되었으나 소프트웨어의 
		규모가 커지면서 또다시 메소드가 없었을때와 같은 경험을 하게됨. 그리하여 도출된 기능이 객체지향.
	- 좋은설계는 높은응집도, 낮은 결합도를 가지는것임
	- 높은 응집도 : 비슷한놈들이 모여있음
	- 낮은 결합도 : 의존도가 줄어들었다.
	- '은닉화, 캡슐화' : 어떻게 동작하는지 원리를 몰라도 사용법만 알면 사용할 수 있음.
		전화번호는 국제적으로 어떻게 한사람이 하나의 번호를부여받고
		통신사는 어떻게 그것을 관리하며
		4g 5g는 무엇이고 우리가 전화번호로 통화버튼을 누르면 어떤 정보가 어디로 가서 어떻게 처리되어 통화 작업이 일어나는지
		음성은 어떻게 데이터화 되어 전달되는지 을 몰라도 통화를할수있음 
		
- Class 는 객체에대한 설계도이다.
- 설계도 대로 인스턴스(객체)를 하나만들면 그제서야 메모리에 올라간다.
	- this 는 현재파일에 있는함수를 쓰기 this 는 생략이 가능하다.
    다만 생략은 거진쓰지않는다. 왜냐하면
	인자를 받을때에 String name 가 존재 한다면 인자의 name 으로 들어가기때문에 함수내의 객체를 사용할때에는
	this 를 사용하여 쓴다.
----    
	public void taming(Cat animal) {
	
		System.out.println(this.name+"이 " +animal.name+"을(를) 길들이겠습니다.");
	}
----    
- Overlode : 스타크래프트의 오버로드 생각해보면됨 이것도싣고 저것도싣고 
- 함수의 이름이 같은데 파라미터가 다를경우
- 서로다른 함수같이 작동되는 메커니즘이다.

- 호출할때의 데이터 타입과 갯수를 보고 그렇게 정의 했던 함수가 매칭되어 호출된다.(인자가3개면 3개를 모두 써야 호출된다.)
- 코드를 짤때 순서가 중요하다,

- 프로그래밍 패러다임
- 절차지향적 순서대로감 C언어

- 객체지향적 : 자바는 객체지향적언어
	- 장점 : 사람이 세상을 보는것과 같은 방식이다.
	- 단점 : 간단한거 하나를 만드려해도 설계부터 해야한다. 

- 함수지향적 


- 자바스크립트는 함수를 객체처럼 생각한다.
- 자바스크립트에서는 일급객체이기때문에 다른함수의 인자로 전달받을수있다.
* 자바 스크립트는 함수형 프로그래밍 이지만 복합적은 패러다임이 모여있다고함.
- 자바스크립트는 일급객체이다.
- 일급객체
- 참고자료 https://velog.io/@reveloper-1311/%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4First-Class-Object%EB%9E%80
- 비동기적 프로그래밍을 하기위해 콜백함수를 쓴다.
- 비동기적 : 동기적이지 않다.
	- a가 시작한것이 끝나지 않았음에도 b가 시작할수있는것
	   
- 동기적 == 절차적 : a가 끝이나야 b가 시작되는 서로다른 두 객체간의 시간적 값의 일치
- 지금진행하는작업이 끝나면 다른작업이시작됨
- 왜 비동기적 프로그래밍을 하는가
	- 동기적 프로그래밍의 단점 : 에러가 나면 멈춘다. 순차적으로 진행돼어 속도가 느림. 
	- 병렬적으로 일을 처리할수있기 떄문에 속도를 높일수있다.
	- 반드시 나 이전의 일이 끝나기를 기다릴 필요가 없을때에 병렬적으로 일을처리하면 속도를 높일수 있기때문에 사용한다.
- 공부의 순서 why와 의지 했는데 안되는것을 계속 해야함.


# 접근제한자, 접근제어자
- private : 해당 클래스에서만 접근이 가능
- default : 해당 패키지 내에서만 접근이 가능
- protected : 동일 패키지의 클래스 또는 해당 클래스를 상속받은 다른 패키지의 클래스에서만 접근이 가능
- public : 어떤 클래스에서라도 접근이 가능


# 생성자 Constructor객체
- 역할 : 객체를 인스턴스(생성)화 하는 역할
- 문법 : 함수와 비슷하게 생겼는데 이름이 클래스명이고 리턴값이 없다. 
	- new키워드와 함께 생성자를 호출가능.
	 - ex) Apple myfruit = new Apple();
- 객체를 생성할 때 new 키워드와 함께 사용. 생성할때 필요한 데이터를 강제하는 역할.
- 클래스에는 반드시 최소하나이상의 생성자가 존재.
- 클래스에 생성자가 명시적으로 없더라도 컴파일러가 디폴트 생성자를 넣어준다.
- 사용자 정의 생성자가 하나라도있으면 디폴트 생성자는 만들어지지 않는다.
- 디폴트 생성자는 매개변수와 구현부가 없다.

- super는 부모를말한다.
- super(); 부모의 디폴트 생성자를 호출한것이다.
- 자바에서 모든 class는 원시조상 Object를 상속받고있다.

- 생성자가 무엇인지 설명하고 왜 쓰는지 설명해보세요.
    - 객체를 생성할때 쓴다.
    - 객체가 생성될때 필요한 데이터를 강제하는역할을 한다.
    - 필요한 데이터가 준비되었다면 쉽게 객체를 만들수 있도록 한다.
    - 데이터가 아직 준비되지 않았다면 객체를 생성할수없도록 한다.

# 추상클래스 : 자식 extends 부모.   하나의 부모'만' 가질수있다.
- 동물 > 척추동물 > 포유강 > 식육목 > 고양잇과 > 표범아과 > 표범
- 클래스가 미완성이라는것은 추상메소드가(abstract가 붙은 메소드) 하나 이상 포함된 클래스라는 말.
- 개념 :
	- 우리 아빠의 그랜저 : 인스턴스
	- 현대 자동차의 그랜저 설계도 : 클래스
	- 그랜저라는 개념 : 객체
	- 중국으로 일부 유출된그랜저 설계도 : 추상클래스

# 상속 extends

----

    public class Slime extends Monster{

        public Slime(String name, int hp) {
            super(name, hp);
            // TODO Auto-generated constructor stub
        }
        
        
    }

----

- 오버로딩 = 과적재 = 이거를 싣었다가 다른것을 싣엇다가
- 오버라이드 = 오버라이트 = 덮어쓰기.
- 상속이라는 개념을 먼저 알아야됨. 부모클래스와 extends(호출)
	- override : 부모에 있는 메소의 형태와 같은 메소드를 자식에 선언했을때 자식의 메소드가 부모의 메소드를 덮어쓰는 메커니즘
- 오버라이드 : 상속을받았을때 자식에서 똑같은이름으로 추가적인 함수 또는 별도의 함수를 만들고 싶을때 사용
- 오버로딩 : 하나의 함수이름으로 여러개를 돌리고싶을때 사용
	함수의 이름이 같을떄 파라미터가 다른 여러함수를 정의해놨을때
	함수 호출시에 그에 맞는 함수가 호출된다.
- 자바는 오버라이드를 통해 다형성을 구현.
- https://private.tistory.com/25 오버로드 라이드

----

    int a = 5;
    Man hong = new Man("홍길동");


- 데이터타입 변수명 = 값;

# 추상클래스
	
- abstract 키워드가 붙은 메소드가 하나라도 있는 클래스
- 사실은 구현을하다가 만놈(완벽하게 개발을 끝내지 못한놈) 인데
- 클래스도 추상클래스로 변환
- 내가 만든 클래스를 다른사람이 상속받게되면 미완성된것을 사용하게된다.
- 추상클래스로는 인스턴스를 만들수없다. 왜? 미완성됬으니까.
- 상속을받은 클래스는 부모에게서 미구현된 메서드는 자식클래스에서 꼭 재정의 해줘야한다.
- 자식에서 반드시 추상매소드를 오버라이드 해줘야한다.