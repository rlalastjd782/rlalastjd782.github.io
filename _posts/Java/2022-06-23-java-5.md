---
title:  "JAVA 공부4(람다식)"
excerpt : "자바공부 끄적끄적."

categories:
  - Java
tags:
  - Java

toc: true
toc_sticky: true
 
date: 2022-06-23
last_modified_at: 2022-06-23
---


# 자바공부4
- 자바 단어공부 끄적끄적

# 람다식(Lamda Expression)   람다함수
- 자바8에 도입된 함수적 프로그래밍 기법이다. 람다가 포함되면서 자바가 완전해졌다고 말하는 이가 있을정도다.
- 익명함수를 람다함수라고 한다.  익명함수는 반환타입과 이름이 없다.
   - 함수형프로그래밍이 무엇인지 먼저 알아야 한다. 쉽게 말하자면 최대한 많은 함수를 순수함수로 만들어 유지보수하기 쉽도록 만드는 패러다임이며 디테일하게 말하자면 아래와 같다.
- 함수형 프로그래밍에서 함수를 만들때는 side effect(부작용 : 부수효과)를 최대한 주지 않도록 구현하는데 아예없는 함수를 순수함수라고 한다. 
  - 순수함수 : side effect(부작용 : 부수효과)가 없는 함수.
  - 부수효과는 인풋과 아웃풋이라는 함수 본질이 아니라 반환값 이외에는 함수밖에서 관찰할수 있는 상태변화가 발생하는 모든것을 말한다.
  - 사이드이펙트를 가진 함수가 많아지면 디버깅하기가 매우 어려워지게 된다. 각 함수 내부를 뒤져서 이게 어디에 영향을 주는지 파악해야한다.
  - 인풋이 같으면 언제나 같은 아웃풋이 나와야 한다.
  - 예를들어서 현재시간을 함수내부에서 사용한다면 인풋이 같을때 아웃풋이 달라질 수 있기때문에 순수함수가 아니다.
  - 순수함수가 될려면 외부에서 시간을 주입받아야 한다.
  - 그러다보니 동시에 여러함수들이 호출돼도 문제가 없다. 병렬처리가 가 능하다.
  - 그리고 함수형 프로그래밍에서는 모든것을 객체로 취급한다. 함수는 일급객체로 취급한다.
  - **그래서 사실 람다식은 익명함수가 아니라 익명객체다.**
  - 자바스크립트나 파이썬같은곳에서는 함수가 일급객체라 람다식 사용이 쉬운데
  - 자바는 객체지향프로그래밍 문법이라 함수는 함수고 객체는 객체라 문법적으로 이상해진다.
  - 여기서 어려움이 발생한다. 자바스크립트의 화살표함수로 (a,b) => a>b? a:b 짜면 매우 간단한다.


```javascript
let max = (a,b) => a>b? a:b;
max(5,7);
```


- 그런데 자바에서는 아래와 같이 클래스에 종속적이게 만들어야한다.


```java
new Object(){
  int max(int a, int b){
    return a>b? a:b;
  }
}
//클래스명 인스턴스명 = new 클래스명(); 
//앞에 대입받는 인스턴스가 없기 때문에 이름이없는 익명객체이다.

```

- 이름이 없는 익명객체다. 객체의 선언과 생성을 동시에 하고있다.
- 자바의 모든 메소드는 클래스 안에만 위치할수있다. 
  그래서 자바에서는 메서드만 전달할 수 있는 방법이 없다. 
  그래서 **매번 인스턴스를 만들어서 전달**해줘야 하고 매우 불편했다. 그것을 해결하기 위해 도입한것이 람다식이며 
  함수형언어에서 함수는 일급객체이기 때문에 클래스에 독립적이다는 개념을 이용한 것이다.
-  (**중요**)익명함수를 생성하는 식으로 보이지만 런타임시에 익명 구현 객체를 생성한다.
-  정의문법 :  (데이터타입 매개변수) -> { 실행문; }
    - 반환타입과 메서드명을 지우고 {} 앞에 ->를 넣으면 된다.
    - 매개변수가 하나일때 괄호생략가능. 
    - 예) (x) => {return x*x*x}; x->{return x*x*x}
     - 단, 타입을 명시적으로 줬다면 생략불가.
     - 본문이 한줄일때 중괄호생략가능. 세미콜론 생략해야됨. 
     - 그런데 그하나의 문장이 return문이면 {} 생략불가
     - 그런데 아예 return 키워드를 빼면 또 {} 생략가능
  - 매개변수의 타입이 추론가능하면 생략가능(대부분 생략가능)
  - 그래서
```java 
   (int x, int y) -> {return x+y};
  (x, y) -> {return x+y};
  (x, y) -> x+y;


// 예시로 연습
  int max(int a, int b){
      return a>b? a: b;
  }
  변환 : (a,b) -> a>b? a: b

  int printVar(String name, int i){
    System.out.println(name +"="+i);
  }
  변환 : (name, i) -> System.out.println(name +"="+i)

  int square(int x){
    return x*x;
  }
  변환 : x -> x*x

  int roll(){
    return (int)(Math.random()*6);
  }
  변환 : ()->(int)(Math.random()*6)


  for(int i=0; i<10; i++){
    System.out.prinln(i);
  }
  변 환 : IntStream.range(0, 10).forEach((콜백함수);
  //근데 자바에서는 함수만 함수의 파라미터로 전달해줄수가 없다. 그래서 아래와같이 쓴다.
   IntStream.range(0, 10).forEach((int value) -> System.out.println(value));
```
- (**실제구현**)
    - 자바에서는 문법상 메소드만 만들 순 없잖아. 클래스안에 있어야하지.
    - 그런데 우리가 만들려고하는건 함수 하나다. 그래서 람다식용으로 함수하나만 포함하고있는 인터페이스를 만들거다.
    - 함수가 단 하나만 있는 인터페이스를 **함수형 인터페이스** 라고 한다. 우리가 쓰레드할때 썼던 Runnable 인터페이스도 run함수 하나뿐인 함수형 인터페이스다.
    - 함수가 하나밖에 없기 때문에 JVM이 자동으로 무조건 그놈으로 매핑을 해 줄 수 있다.
    - 그래서 인터페이스 명 = () -> {본문}  을 하면 해당 인터페이스의 익명 구현 객체로 생성된다. 그놈을 인스턴스에 넣어서 쓸거다.
    - 코드를 예로 한번 보면 훨씬 이해가 쉽다.
    - 
  1. 함수형 인터페이스(어떤 하수 하나에 대한 약속)만들기
```java
  public interface Add{
    public int add(int x, int y);
  }
  // 1. 쓸 클래스의 함수안 람다식 구현하기
  Add 아무이름 = (x,y) -> {return x+y;};   // 우변{return x+y;}은 람다식만 쓴거
                                          // 이부분이 위에서 말한 자동매핑 부분이다.
```                                          
  3. 호출하기
  - System.out.println(아무이름.add(2,3));
- 매개변수타입은 런타임시 대입되는 값에 따라 자동으로 인식될수 있기 때문에 일반적으로 언급하지 않는다.
- 장점 (람다식의 장점이지 자바에서의 람다식은 문법상 상쇄.)
  1. 코드가 매우 간결해진다.
  2. 인스턴스 생성 안하고 기능실행 // 클래스의 인스턴스를 생성하지않는거지 자바 문법상 인스턴스는 있을수밖에 없다
  3. 함수이름 생각 할 필요없음
  4. 컬렉션요소를 매핑해서 쉽게 집계할 수 있다.
- 단점
  1. 가독성이 안좋아진다.
  2. 함수이름이 없기 때문에 stacktrace보고 디버깅하기 어렵다.
  3. 이 함수가 있음을 인식하기가 어렵다.
- 결론
  - 위의 단점들때문에 람다식 쓰지말라고도 하는개발자들도 많다.
  - 본문이 3줄안에 끝나고 단 한번만 쓰임을 보장할수있고 행동이 - 명확할때만 제한적으로 사용.

- @FunctionalInterface
- Functional Interface라는것을 알려준다. '구현해야 할 추상 메소드가 하나만 정의된 인터페이스'를 가리킨다.
- 그래서 함수가 2개이상있으면 에러를 발생시킨다.